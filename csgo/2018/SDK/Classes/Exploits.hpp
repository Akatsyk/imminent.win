#pragma once
#include "../Valve/netadr.h"
#include "../Valve/platform.hpp"
#include "../Valve/vector.hpp"
#include "../Valve/vector2d.hpp"
#include "../Valve/matrix.hpp"
#include "../Valve/qangle.hpp"
#include "CStudioRender.hpp"

#define OUT_Z_CAP(x) _Out_z_cap_(x)
#define UDP_HEADER_SIZE 28

//-----------------------------------------------------------------------------
// Helpers.
//-----------------------------------------------------------------------------

inline int BitByte(int bits)
{
	// return PAD_NUMBER( bits, 8 ) >> 3;
	return (bits + 7) >> 3;
}

//-----------------------------------------------------------------------------
enum EBitCoordType
{
	kCW_None,
	kCW_LowPrecision,
	kCW_Integral
};

//-----------------------------------------------------------------------------
// namespaced helpers
//-----------------------------------------------------------------------------
namespace bitbuf
{
	// ZigZag Transform:  Encodes signed integers so that they can be
	// effectively used with varint encoding.
	//
	// varint operates on unsigned integers, encoding smaller numbers into
	// fewer bytes.  If you try to use it on a signed integer, it will treat
	// this number as a very large unsigned integer, which means that even
	// small signed numbers like -1 will take the maximum number of bytes
	// (10) to encode.  ZigZagEncode() maps signed integers to unsigned
	// in such a way that those with a small absolute value will have smaller
	// encoded values, making them appropriate for encoding using varint.
	//
	//       int32 ->     uint32
	// -------------------------
	//           0 ->          0
	//          -1 ->          1
	//           1 ->          2
	//          -2 ->          3
	//         ... ->        ...
	//  2147483647 -> 4294967294
	// -2147483648 -> 4294967295
	//
	//        >> encode >>
	//        << decode <<

	inline uint32 ZigZagEncode32(int32 n)
	{
		// Note:  the right-shift must be arithmetic
		return(n << 1) ^ (n >> 31);
	}

	inline int32 ZigZagDecode32(uint32 n)
	{
		return(n >> 1) ^ -static_cast<int32>(n & 1);
	}

	inline uint64 ZigZagEncode64(int64 n)
	{
		// Note:  the right-shift must be arithmetic
		return(n << 1) ^ (n >> 63);
	}

	inline int64 ZigZagDecode64(uint64 n)
	{
		return(n >> 1) ^ -static_cast<int64>(n & 1);
	}

	const int kMaxVarintBytes = 10;
	const int kMaxVarint32Bytes = 5;
}

class CBitBuffer
{
public:
	char const* m_pDebugName;
	bool m_bOverflow;
	int m_nDataBits;
	size_t m_nDataBytes;

	void SetDebugName(char const* pName)
	{
		m_pDebugName = pName;
	}

	CBitBuffer(void)
	{
		m_bOverflow = false;
		m_pDebugName = 0;
		m_nDataBits = -1;
		m_nDataBytes = 0;
	}

	__forceinline void SetOverflowFlag(void)
	{
		m_bOverflow = true;
	}

	__forceinline bool IsOverflowed(void) const
	{
		return m_bOverflow;
	}

	static const unsigned int s_nMaskTable[33];							// 0 1 3 7 15 ..
};

class CBitWrite : public CBitBuffer
{
	uint32 m_nOutBufWord;
	int m_nOutBitsAvail;
	uint32* m_pDataOut;
	uint32* m_pBufferEnd;
	uint32* m_pData;
	bool m_bFlushed;

public:
	void StartWriting(void* pData, int nBytes, int iStartBit = 0, int nMaxBits = -1);


	CBitWrite(void* pData, int nBytes, int nBits = -1)
	{
		m_bFlushed = false;
		StartWriting(pData, nBytes, 0, nBits);
	}

	CBitWrite(const char* pDebugName, void* pData, int nBytes, int nBits = -1)
	{
		m_bFlushed = false;
		SetDebugName(pDebugName);
		StartWriting(pData, nBytes, 0, nBits);
	}

	CBitWrite(void)
	{
		m_bFlushed = false;
	}

	~CBitWrite(void)
	{
		TempFlush();
		Assert((!m_pData) || m_bFlushed);
	}
	__forceinline int GetNumBitsLeft(void) const
	{
		return m_nOutBitsAvail + (32 * (m_pBufferEnd - m_pDataOut - 1));
	}

	__forceinline void Reset(void)
	{
		m_bOverflow = false;
		m_nOutBitsAvail = 32;
		m_pDataOut = m_pData;
		m_nOutBufWord = 0;

	}

	__forceinline void TempFlush(void)
	{
		// someone wants to know how much data we have written, or the pointer to it, so we'd better make
		// sure we write our data
		if (m_nOutBitsAvail != 32)
		{
			if (m_pDataOut == m_pBufferEnd)
			{
				SetOverflowFlag();
			}
			else
			{
				StoreLittleDWord(m_pDataOut, 0, LoadLittleDWord(m_pDataOut, 0) & ~s_nMaskTable[32 - m_nOutBitsAvail] | m_nOutBufWord);
			}
		}
		m_bFlushed = true;
	}

	__forceinline unsigned char* GetBasePointer()
	{
		TempFlush();
		return reinterpret_cast<unsigned char*>(m_pData);
	}

	__forceinline unsigned char* GetData()
	{
		return GetBasePointer();
	}

	__forceinline void Finish();
	__forceinline void Flush();
	__forceinline void FlushNoCheck();
	__forceinline void WriteOneBit(int nValue);
	__forceinline void WriteOneBitNoCheck(int nValue);
	__forceinline void WriteUBitLong(unsigned int data, int numbits, bool bCheckRange = true);
	__forceinline void WriteSBitLong(int data, int numbits);
	__forceinline void WriteUBitVar(unsigned int data);
	__forceinline void WriteBitFloat(float flValue);
	__forceinline void WriteFloat(float flValue);
	bool WriteBits(const void* pInData, int nBits);
	void WriteBytes(const void* pBuf, int nBytes);
	void SeekToBit(int nSeekPos);

	__forceinline int GetNumBitsWritten(void) const
	{
		return (32 - m_nOutBitsAvail) + (32 * (m_pDataOut - m_pData));
	}

	__forceinline int GetNumBytesWritten(void) const
	{
		return (GetNumBitsWritten() + 7) >> 3;
	}


	__forceinline void WriteLong(int32 val)
	{
		WriteSBitLong(val, 32);
	}



	__forceinline void WriteChar(int val)
	{
		WriteSBitLong(val, sizeof(char) << 3);
	}

	__forceinline void WriteByte(int val)
	{
		WriteUBitLong(val, sizeof(unsigned char) << 3, false);
	}

	__forceinline void WriteShort(int val)
	{
		WriteSBitLong(val, sizeof(short) << 3);
	}

	__forceinline void WriteWord(int val)
	{
		WriteUBitLong(val, sizeof(unsigned short) << 3);
	}

	bool WriteString(const char* pStr);
	bool WriteString(const wchar_t* pStr);

	void WriteLongLong(int64 val);

	void WriteBitAngle(float fAngle, int numbits);
	void WriteBitCoord(const float f);
	void WriteBitCoordMP(const float f, EBitCoordType coordType);
	void WriteBitCellCoord(const float f, int bits, EBitCoordType coordType);
	void WriteBitVec3Coord(const Vector& fa);
	void WriteBitNormal(float f);
	void WriteBitVec3Normal(const Vector& fa);
	void WriteBitAngles(const QAngle& fa);

	// Copy the bits straight out of pIn. This seeks pIn forward by nBits.
	// Returns an error if this buffer or the read buffer overflows.
	bool WriteBitsFromBuffer(class bf_read* pIn, int nBits);

};

void CBitWrite::Finish(void)
{
	if (m_nOutBitsAvail != 32)
	{
		if (m_pDataOut == m_pBufferEnd)
		{
			SetOverflowFlag();
		}
		StoreLittleDWord(m_pDataOut, 0, m_nOutBufWord);
	}
}

void CBitWrite::FlushNoCheck(void)
{
	StoreLittleDWord(m_pDataOut++, 0, m_nOutBufWord);
	m_nOutBitsAvail = 32;
	m_nOutBufWord = 0;										// ugh - I need this because of 32 bit writes. a<<=32 is a nop

}
void CBitWrite::Flush(void)
{
	if (m_pDataOut == m_pBufferEnd)
	{
		SetOverflowFlag();
	}
	else
	{
		StoreLittleDWord(m_pDataOut++, 0, m_nOutBufWord);
	}
	m_nOutBufWord = 0;										// ugh - I need this because of 32 bit writes. a<<=32 is a nop
	m_nOutBitsAvail = 32;

}
void CBitWrite::WriteOneBitNoCheck(int nValue)
{
	m_nOutBufWord |= (nValue & 1) << (32 - m_nOutBitsAvail);
	if (--m_nOutBitsAvail == 0)
	{
		FlushNoCheck();
	}
}

void CBitWrite::WriteOneBit(int nValue)
{
	m_nOutBufWord |= (nValue & 1) << (32 - m_nOutBitsAvail);
	if (--m_nOutBitsAvail == 0)
	{
		Flush();
	}
}

__forceinline void CBitWrite::WriteUBitLong(unsigned int nData, int nNumBits, bool bCheckRange)
{

#ifdef _DEBUG
	// Make sure it doesn't overflow.
	if (bCheckRange && nNumBits < 32)
	{
		Assert(nData <= (uint32)(1 << nNumBits));
	}
	Assert(nNumBits >= 0 && nNumBits <= 32);
#endif
	if (nNumBits <= m_nOutBitsAvail)
	{
		if (bCheckRange)
			m_nOutBufWord |= (nData) << (32 - m_nOutBitsAvail);
		else
			m_nOutBufWord |= (nData & s_nMaskTable[nNumBits]) << (32 - m_nOutBitsAvail);
		m_nOutBitsAvail -= nNumBits;
		if (m_nOutBitsAvail == 0)
		{
			Flush();
		}
	}
	else
	{
		// split dwords case
		int nOverflowBits = (nNumBits - m_nOutBitsAvail);
		m_nOutBufWord |= (nData & s_nMaskTable[m_nOutBitsAvail]) << (32 - m_nOutBitsAvail);
		Flush();
		m_nOutBufWord = (nData >> (nNumBits - nOverflowBits));
		m_nOutBitsAvail = 32 - nOverflowBits;
	}
}

__forceinline void CBitWrite::WriteSBitLong(int nData, int nNumBits)
{
	WriteUBitLong((uint32)nData, nNumBits, false);
}

__forceinline void CBitWrite::WriteUBitVar(unsigned int n)
{
	if (n < 16)
		WriteUBitLong(n, 6);
	else
		if (n < 256)
			WriteUBitLong((n & 15) | 16 | ((n & (128 | 64 | 32 | 16)) << 2), 10);
		else
			if (n < 4096)
				WriteUBitLong((n & 15) | 32 | ((n & (2048 | 1024 | 512 | 256 | 128 | 64 | 32 | 16)) << 2), 14);
			else
			{
				WriteUBitLong((n & 15) | 48, 6);
				WriteUBitLong((n >> 4), 32 - 4);
			}
}

__forceinline void CBitWrite::WriteBitFloat(float flValue)
{
	WriteUBitLong(*((uint32*)&flValue), 32);
}

__forceinline void CBitWrite::WriteFloat(float flValue)
{
	// Pre-swap the float, since WriteBits writes raw data
	LittleFloat(&flValue, &flValue);
	WriteUBitLong(*((uint32*)&flValue), 32);
}

class CBitRead : public CBitBuffer
{
	uint32 m_nInBufWord;
	int m_nBitsAvail;
	uint32 const* m_pDataIn;
	uint32 const* m_pBufferEnd;
	uint32 const* m_pData;

public:
	CBitRead(const void* pData, int nBytes, int nBits = -1)
	{
		StartReading(pData, nBytes, 0, nBits);
	}

	CBitRead(const char* pDebugName, const void* pData, int nBytes, int nBits = -1)
	{
		SetDebugName(pDebugName);
		StartReading(pData, nBytes, 0, nBits);
	}

	CBitRead(void) : CBitBuffer()
	{
	}

	__forceinline int Tell(void) const
	{
		return GetNumBitsRead();
	}

	__forceinline size_t TotalBytesAvailable(void) const
	{
		return m_nDataBytes;
	}

	__forceinline int GetNumBitsLeft() const
	{
		return m_nDataBits - Tell();
	}

	__forceinline int GetNumBytesLeft() const
	{
		return GetNumBitsLeft() >> 3;
	}

	bool Seek(int nPosition);

	__forceinline bool SeekRelative(int nOffset)
	{
		return Seek(GetNumBitsRead() + nOffset);
	}

	__forceinline unsigned char const* GetBasePointer()
	{
		return reinterpret_cast<unsigned char const*>(m_pData);
	}

	void StartReading(const void* pData, int nBytes, int iStartBit = 0, int nBits = -1);

	__forceinline int GetNumBitsRead(void) const;
	__forceinline int GetNumBytesRead(void) const;

	__forceinline void GrabNextDWord(bool bOverFlowImmediately = false);
	__forceinline void FetchNext(void);
	__forceinline unsigned int ReadUBitLong(int numbits);
	__forceinline int ReadSBitLong(int numbits);
	__forceinline unsigned int ReadUBitVar(void);
	__forceinline unsigned int PeekUBitLong(int numbits);
	__forceinline float ReadBitFloat(void);
	float ReadBitCoord();
	float ReadBitCoordMP(EBitCoordType coordType);
	float ReadBitCellCoord(int bits, EBitCoordType coordType);
	float ReadBitNormal();
	void ReadBitVec3Coord(Vector& fa);
	void ReadBitVec3Normal(Vector& fa);
	void ReadBitAngles(QAngle& fa);
	bool ReadBytes(void* pOut, int nBytes);
	float ReadBitAngle(int numbits);

	// Returns 0 or 1.
	__forceinline int	ReadOneBit(void);
	__forceinline int ReadLong(void);
	__forceinline int ReadChar(void);
	__forceinline int ReadByte(void);
	__forceinline int ReadShort(void);
	__forceinline int ReadWord(void);
	__forceinline float ReadFloat(void);
	void ReadBits(void* pOut, int nBits);

	// Returns false if bufLen isn't large enough to hold the
	// string in the buffer.
	//
	// Always reads to the end of the string (so you can read the
	// next piece of data waiting).
	//
	// If bLine is true, it stops when it reaches a '\n' or a null-terminator.
	//
	// pStr is always null-terminated (unless bufLen is 0).
	//
	// pOutN<umChars is set to the number of characters left in pStr when the routine is 
	// complete (this will never exceed bufLen-1).
	//
	bool ReadString(char* pStr, int bufLen, bool bLine = false, int* pOutNumChars = NULL);
	bool ReadWString(OUT_Z_CAP(maxLenInChars) wchar_t* pStr, int maxLenInChars, bool bLine = false, int* pOutNumChars = NULL);
	char* ReadAndAllocateString(bool* pOverflow = 0);

	int64 ReadLongLong(void);

	// reads a varint encoded integer
	uint32			ReadVarInt32();
	uint64			ReadVarInt64();
	int32			ReadSignedVarInt32() { return bitbuf::ZigZagDecode32(ReadVarInt32()); }
	int64			ReadSignedVarInt64() { return bitbuf::ZigZagDecode64(ReadVarInt64()); }
};


__forceinline int CBitRead::GetNumBitsRead(void) const
{
	if (!m_pData)									   // pesky null ptr bitbufs. these happen.
		return 0;

	int nCurOfs = int(((intptr_t(m_pDataIn) - intptr_t(m_pData)) / 4) - 1);
	nCurOfs *= 32;
	nCurOfs += (32 - m_nBitsAvail);
	int nAdjust = 8 * (m_nDataBytes & 3);
	return std::min(nCurOfs + nAdjust, m_nDataBits);
}

__forceinline int CBitRead::GetNumBytesRead(void) const
{
	return ((GetNumBitsRead() + 7) >> 3);
}

__forceinline void CBitRead::GrabNextDWord(bool bOverFlowImmediately)
{
	if (m_pDataIn == m_pBufferEnd)
	{
		m_nBitsAvail = 1;									// so that next read will run out of words
		m_nInBufWord = 0;
		m_pDataIn++;										// so seek count increments like old
		if (bOverFlowImmediately)
			SetOverflowFlag();
	}
	else
		if (m_pDataIn > m_pBufferEnd)
		{
			SetOverflowFlag();
			m_nInBufWord = 0;
		}
		else
		{
			Assert(reinterpret_cast<intptr_t>(m_pDataIn) + 3 < reinterpret_cast<intptr_t>(m_pBufferEnd));
			m_nInBufWord = LittleDWord(*(m_pDataIn++));
		}
}

__forceinline void CBitRead::FetchNext(void)
{
	m_nBitsAvail = 32;
	GrabNextDWord(false);
}

int CBitRead::ReadOneBit(void)
{
	int nRet = m_nInBufWord & 1;
	if (--m_nBitsAvail == 0)
	{
		FetchNext();
	}
	else
		m_nInBufWord >>= 1;
	return nRet;
}


unsigned int CBitRead::ReadUBitLong(int numbits)
{
	if (m_nBitsAvail >= numbits)
	{
		unsigned int nRet = m_nInBufWord & s_nMaskTable[numbits];
		m_nBitsAvail -= numbits;
		if (m_nBitsAvail)
		{
			m_nInBufWord >>= numbits;
		}
		else
		{
			FetchNext();
		}
		return nRet;
	}
	else
	{
		// need to merge words
		unsigned int nRet = m_nInBufWord;
		numbits -= m_nBitsAvail;
		GrabNextDWord(true);
		if (m_bOverflow)
			return 0;
		nRet |= ((m_nInBufWord & s_nMaskTable[numbits]) << m_nBitsAvail);
		m_nBitsAvail = 32 - numbits;
		m_nInBufWord >>= numbits;
		return nRet;
	}
}

__forceinline unsigned int CBitRead::PeekUBitLong(int numbits)
{
	int nSaveBA = m_nBitsAvail;
	int nSaveW = m_nInBufWord;
	uint32 const* pSaveP = m_pDataIn;
	unsigned int nRet = ReadUBitLong(numbits);
	m_nBitsAvail = nSaveBA;
	m_nInBufWord = nSaveW;
	m_pDataIn = pSaveP;
	return nRet;
}

__forceinline int CBitRead::ReadSBitLong(int numbits)
{
	int nRet = ReadUBitLong(numbits);
	// sign extend
	return (nRet << (32 - numbits)) >> (32 - numbits);
}

__forceinline int CBitRead::ReadLong(void)
{
	return (int)ReadUBitLong(sizeof(int32) << 3);
}

__forceinline float CBitRead::ReadFloat(void)
{
	uint32 nUval = ReadUBitLong(sizeof(int32) << 3);
	return *((float*)&nUval);
}

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable : 4715)								// disable warning on not all cases
// returning a value. throwing default:
// in measurably reduces perf in bit
// packing benchmark
#endif
__forceinline unsigned int CBitRead::ReadUBitVar(void)
{
	unsigned int ret = ReadUBitLong(6);
	switch (ret & (16 | 32))
	{
	case 16:
		ret = (ret & 15) | (ReadUBitLong(4) << 4);
		Assert(ret >= 16);
		break;

	case 32:
		ret = (ret & 15) | (ReadUBitLong(8) << 4);
		Assert(ret >= 256);
		break;
	case 48:
		ret = (ret & 15) | (ReadUBitLong(32 - 4) << 4);
		Assert(ret >= 4096);
		break;
	}
	return ret;
}
#ifdef _WIN32
#pragma warning(pop)
#endif

__forceinline float CBitRead::ReadBitFloat(void)
{
	uint32 nvalue = ReadUBitLong(32);
	return *((float*)&nvalue);
}

int CBitRead::ReadChar(void)
{
	return ReadSBitLong(sizeof(char) << 3);
}

int CBitRead::ReadByte(void)
{
	return ReadUBitLong(sizeof(unsigned char) << 3);
}

int CBitRead::ReadShort(void)
{
	return ReadSBitLong(sizeof(short) << 3);
}

int CBitRead::ReadWord(void)
{
	return ReadUBitLong(sizeof(unsigned short) << 3);
}

#define WRAP_READ( bc ) 																									  \
class bf_read : public bc																									  \
{																															  \
public:																														  \
    __forceinline bf_read( void ) : bc(  )																								  \
	{																														  \
	}																														  \
																															  \
	__forceinline bf_read( const void *pData, int nBytes, int nBits = -1 ) : bc( pData, nBytes, nBits )									  \
	{																														  \
	}																														  \
																															  \
	__forceinline bf_read( const char *pDebugName, const void *pData, int nBytes, int nBits = -1 ) : bc( pDebugName, pData, nBytes, nBits ) \
	{																														  \
	}																														  \
};

class bf_read {
public:
  const char* m_pDebugName;
  bool m_bOverflow;
  int m_nDataBits;
  unsigned int m_nDataBytes;
  unsigned int m_nInBufWord;
  int m_nBitsAvail;
  const unsigned int* m_pDataIn;
  const unsigned int* m_pBufferEnd;
  const unsigned int* m_pData;

  bf_read( ) = default;

  bf_read( const void* pData, int nBytes, int nBits = -1 ) {
	 StartReading( pData, nBytes, 0, nBits );
  }

  void StartReading( const void* pData, int nBytes, int iStartBit, int nBits ) {
	 // Make sure it's dword aligned and padded.
	 m_pData = ( uint32_t* )pData;
	 m_pDataIn = m_pData;
	 m_nDataBytes = nBytes;

	 if( nBits == -1 ) {
		m_nDataBits = nBytes << 3;
	 } else {
		m_nDataBits = nBits;
	 }
	 m_bOverflow = false;
	 m_pBufferEnd = reinterpret_cast< uint32_t const* >( reinterpret_cast< uint8_t const* >( m_pData ) + nBytes );
	 if( m_pData )
		Seek( iStartBit );
  }

  bool Seek( int nPosition ) {
	 bool bSucc = true;
	 if( nPosition < 0 || nPosition > m_nDataBits ) {
		m_bOverflow = true;
		bSucc = false;
		nPosition = m_nDataBits;
	 }
	 int nHead = m_nDataBytes & 3; // non-multiple-of-4 bytes at head of buffer. We put the "round off"
											 // at the head to make reading and detecting the end efficient.

	 int nByteOfs = nPosition / 8;
	 if( ( m_nDataBytes < 4 ) || ( nHead && ( nByteOfs < nHead ) ) ) {
		// partial first dword
		uint8_t const* pPartial = ( uint8_t const* )m_pData;
		if( m_pData ) {
		  m_nInBufWord = *( pPartial++ );
		  if( nHead > 1 )
			 m_nInBufWord |= ( *pPartial++ ) << 8;
		  if( nHead > 2 )
			 m_nInBufWord |= ( *pPartial++ ) << 16;
		}
		m_pDataIn = ( uint32_t const* )pPartial;
		m_nInBufWord >>= ( nPosition & 31 );
		m_nBitsAvail = ( nHead << 3 ) - ( nPosition & 31 );
	 } else {
		int nAdjPosition = nPosition - ( nHead << 3 );
		m_pDataIn = reinterpret_cast< uint32_t const* >(
		  reinterpret_cast< uint8_t const* >( m_pData ) + ( ( nAdjPosition / 32 ) << 2 ) + nHead );
		if( m_pData ) {
		  m_nBitsAvail = 32;
		  GrabNextDWord( );
		} else {
		  m_nInBufWord = 0;
		  m_nBitsAvail = 1;
		}
		m_nInBufWord >>= ( nAdjPosition & 31 );
		m_nBitsAvail = std::min( m_nBitsAvail, 32 - ( nAdjPosition & 31 ) ); // in case grabnextdword overflowed
	 }
	 return bSucc;
  }

  __forceinline void GrabNextDWord( bool bOverFlowImmediately = false ) {
	 if( m_pDataIn == m_pBufferEnd ) {
		m_nBitsAvail = 1; // so that next read will run out of words
		m_nInBufWord = 0;
		m_pDataIn++; // so seek count increments like old
		if( bOverFlowImmediately )
		  m_bOverflow = true;
	 } else if( m_pDataIn > m_pBufferEnd ) {
		m_bOverflow = true;
		m_nInBufWord = 0;
	 } else {
		m_nInBufWord = LittleDWord( *( m_pDataIn++ ) );
	 }
  }
};

class bf_write {
public:
  unsigned char* m_pData;
  int m_nDataBytes;
  int m_nDataBits;
  int m_iCurBit;
  bool m_bOverflow;
  bool m_bAssertOnOverflow;
  const char* m_pDebugName;

  void StartWriting( void* pData, int nBytes, int iStartBit = 0, int nBits = -1 ) {
	 // Make sure it's dword aligned and padded.
	 // The writing code will overrun the end of the buffer if it isn't dword aligned, so truncate to force alignment
	 nBytes &= ~3;

	 m_pData = ( unsigned char* )pData;
	 m_nDataBytes = nBytes;

	 if( nBits == -1 ) {
		m_nDataBits = nBytes << 3;
	 } else {
		m_nDataBits = nBits;
	 }

	 m_iCurBit = iStartBit;
	 m_bOverflow = false;
  }

  bf_write( ) {
	 m_pData = NULL;
	 m_nDataBytes = 0;
	 m_nDataBits = -1; // set to -1 so we generate overflow on any operation
	 m_iCurBit = 0;
	 m_bOverflow = false;
	 m_bAssertOnOverflow = true;
	 m_pDebugName = NULL;
  }

  // nMaxBits can be used as the number of bits in the buffer.
  // It must be <= nBytes*8. If you leave it at -1, then it's set to nBytes * 8.
  bf_write( void* pData, int nBytes, int nBits = -1 ) {
	 m_bAssertOnOverflow = true;
	 m_pDebugName = NULL;
	 StartWriting( pData, nBytes, 0, nBits );
  }

  bf_write( const char* pDebugName, void* pData, int nBytes, int nBits = -1 ) {
	 m_bAssertOnOverflow = true;
	 m_pDebugName = pDebugName;
	 StartWriting( pData, nBytes, 0, nBits );
  }
};

class CLC_Move {
private:
  char __PAD0[0x8]; // 0x0 two vtables
public:
  int m_nBackupCommands; // 0x8
  int m_nNewCommands;    // 0xC
  void* m_data;   // 0x10 std::string
  int _cached_size_;
  uint32_t _has_bits_[( 3 + 31 ) / 32];
};                       // size: 0x50

template < typename T >
class CNetMessagePB : public INetMessage, public T {};
using CCLCMsg_Move_t = CNetMessagePB< CLC_Move >;
